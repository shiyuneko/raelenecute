<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Slither.io Clone - Infinite Space & Realistic Snake</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    height: 100%; width: 100%;
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  #gameCanvas {
    display: block;
    margin: 0;
    background: #121821;
    box-shadow: 0 0 30px #00ffda88, inset 0 0 15px #00ffda88;
    touch-action: none;
    image-rendering: pixelated;
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    border-radius: 0;
  }
  #scoreboard {
    position: fixed;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    color: #00ffda;
    font-size: 22px;
    font-weight: 700;
    text-shadow: 0 0 12px #00ffdaee;
    user-select: none;
    letter-spacing: 0.1em;
    z-index: 10;
    pointer-events: none;
  }
  #instructions {
    position: fixed;
    bottom: 20px;
    width: 100%;
    text-align: center;
    color: #00ffdaaa;
    font-size: 15px;
    font-weight: 500;
    user-select: none;
    z-index: 10;
    pointer-events: none;
  }
</style>
</head>
<body>
<div id="scoreboard">Score: 0</div>
<div id="instructions">Use mouse/touch to steer the snake. Eat colorful glowing food to grow!</div>
<canvas id="gameCanvas"></canvas>
<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Viewport size (canvas size)
  let WIDTH = window.innerWidth;
  let HEIGHT = window.innerHeight;

  // World size (much larger than viewport)
  const WORLD_WIDTH = 3000;
  const WORLD_HEIGHT = 3000;

  // Constants
  const FOOD_COUNT = 80;
  const SNAKE_INITIAL_LENGTH = 14;
  const SEGMENT_SIZE = 18;
  const SNAKE_SPEED = 3.6;
  const TURN_SPEED = 0.05;
  const FOOD_SIZE = 12;

  // Vibrant food colors palette
  const FOOD_COLORS = [
    '#ff3c00', '#ffba00', '#44ff00', '#00ffd5', '#007bff', '#ff00d6', '#ffffff', '#ffaaff', '#aaffff', '#ffff00',
  ];

  // State
  let score = 0;
  let snake = [];
  let snakeDirection = 0;
  let targetDirection = 0;
  let food = [];
  let inputX = WIDTH / 2;
  let inputY = HEIGHT / 2;
  // Snake center position (world coordinates) is snake[0].x/y
  // Viewport center follows snake head each frame

  // Setup canvas
  function resizeCanvas() {
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
  }
  window.addEventListener('resize', () => {
    resizeCanvas();
    inputX = WIDTH / 2;
    inputY = HEIGHT / 2;
  });
  resizeCanvas();

  // Initialize snake at center of world
  function initSnake() {
    snake = [];
    const startX = WORLD_WIDTH / 2;
    const startY = WORLD_HEIGHT / 2;
    for (let i = 0; i < SNAKE_INITIAL_LENGTH; i++) {
      snake.push({
        x: startX - i * SEGMENT_SIZE,
        y: startY,
        angle: 0,
      });
    }
    snakeDirection = 0;
    targetDirection = 0;
  }

  // Initialize food at random world positions with color
  function initFood() {
    food = [];
    while (food.length < FOOD_COUNT) {
      const fx = Math.random() * (WORLD_WIDTH - FOOD_SIZE * 2) + FOOD_SIZE;
      const fy = Math.random() * (WORLD_HEIGHT - FOOD_SIZE * 2) + FOOD_SIZE;
      // Keep away from starting snake position
      if (dist(fx, fy, WORLD_WIDTH / 2, WORLD_HEIGHT / 2) > 150) {
        food.push({
          x: fx,
          y: fy,
          color: FOOD_COLORS[Math.floor(Math.random() * FOOD_COLORS.length)]
        });
      }
    }
  }

  // Utilities
  function angleTo(ax, ay, bx, by) {
    return Math.atan2(by - ay, bx - ax);
  }
  function dist(ax, ay, bx, by) {
    const dx = bx - ax;
    const dy = by - ay;
    return Math.sqrt(dx*dx + dy*dy);
  }
  function normalizeAngle(angle) {
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;
    return angle;
  }

  // Update direction smoothly
  function updateDirection() {
    const diff = normalizeAngle(targetDirection - snakeDirection);
    if (Math.abs(diff) < TURN_SPEED) {
      snakeDirection = targetDirection;
    } else {
      snakeDirection += diff > 0 ? TURN_SPEED : -TURN_SPEED;
      snakeDirection = normalizeAngle(snakeDirection);
    }
  }

  // Move snake head and segments
  function updateSnake() {
    const head = snake[0];
    let newHeadX = head.x + Math.cos(snakeDirection) * SNAKE_SPEED;
    let newHeadY = head.y + Math.sin(snakeDirection) * SNAKE_SPEED;

    // Wrap around world edges
    if (newHeadX < 0) newHeadX += WORLD_WIDTH;
    else if (newHeadX > WORLD_WIDTH) newHeadX -= WORLD_WIDTH;
    if (newHeadY < 0) newHeadY += WORLD_HEIGHT;
    else if (newHeadY > WORLD_HEIGHT) newHeadY -= WORLD_HEIGHT;

    // Insert new head
    snake.unshift({ x: newHeadX, y: newHeadY, angle: snakeDirection });
    // Remove last segment to keep length
    snake.pop();
  }

  // Check collision with food, returns index or -1
  function checkFoodCollision() {
    const head = snake[0];
    for(let i = 0; i < food.length; i++) {
      if(dist(head.x, head.y, food[i].x, food[i].y) < FOOD_SIZE + SEGMENT_SIZE*0.6) {
        return i;
      }
    }
    return -1;
  }

  // Grow snake by duplicating tail segments
  function growSnake(amount) {
    for(let i=0; i<amount; i++) {
      const tailIndex = snake.length - 1;
      const last = snake[tailIndex];
      const prev = snake[tailIndex - 1] || last;
      let dx = last.x - prev.x;
      let dy = last.y - prev.y;
      if(dx === 0 && dy === 0) {
        dx = Math.cos(last.angle + Math.PI);
        dy = Math.sin(last.angle + Math.PI);
      }
      snake.push({
        x: last.x + dx,
        y: last.y + dy,
        angle: last.angle
      });
    }
  }

  // Convert world coords to screen coords relative to viewport center
  function worldToScreen(x, y, viewportX, viewportY) {
    let sx = x - viewportX + WIDTH / 2;
    let sy = y - viewportY + HEIGHT / 2;
    // Wrap around screen edges (for seamless)
    if(sx < -SEGMENT_SIZE) sx += WORLD_WIDTH;
    else if(sx > WIDTH + SEGMENT_SIZE) sx -= WORLD_WIDTH;
    if(sy < -SEGMENT_SIZE) sy += WORLD_HEIGHT;
    else if(sy > HEIGHT + SEGMENT_SIZE) sy -= WORLD_HEIGHT;
    return { x: sx, y: sy };
  }

  // Draw a rounded rectangle (for snake segment body)
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  // Draw snake segment with shading and subtle scale patterns
  function drawSegment(x, y, angle, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);

    // Segment gradient base color teal-green hues
    const baseColorTop = 'rgba(0,255,218,0.75)';
    const baseColorBottom = 'rgba(0,128,128,0.9)';

    let grad = ctx.createLinearGradient(0, -size/2, 0, size/2);
    grad.addColorStop(0, baseColorTop);
    grad.addColorStop(1, baseColorBottom);

    ctx.fillStyle = grad;
    ctx.shadowColor = 'rgba(0,255,218,0.3)';
    ctx.shadowBlur = 8;
    roundRect(ctx, -size*0.65, -size*0.5, size*1.3, size, size*0.4);
    ctx.fill();

    // Scale pattern - draw subtle arcs on top
    ctx.lineWidth = 1.2;
    ctx.strokeStyle = 'rgba(0,180,180,0.7)';
    for(let i = -size*0.5 + 3; i < size*0.5 - 2; i += 6) {
      ctx.beginPath();
      ctx.arc(0, i, 3, Math.PI, 0);
      ctx.stroke();
    }

    ctx.restore();
  }

  // Draw snake head with eyes and highlight to appear more realistic
  function drawHead(x, y, angle, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);

    // Head gradient
    let grad = ctx.createRadialGradient(0, 0, size*0.6, 0, 0, size*1.1);
    grad.addColorStop(0, 'rgba(0,255,218,1)');
    grad.addColorStop(1, 'rgba(0,128,128,0.7)');

    // Head rounded rectangle shape
    ctx.fillStyle = grad;
    roundRect(ctx, -size*0.75, -size*0.6, size*1.5, size*1.2, size*0.7);
    ctx.shadowColor = 'rgba(0,255,218,0.6)';
    ctx.shadowBlur = 20;
    ctx.fill();

    // Eyes as black pupils with white highlights
    const eyeY = -size * 0.18;
    const eyeXoffset = size * 0.4;
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.ellipse(-eyeXoffset, eyeY, size*0.22, size*0.28, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(eyeXoffset, eyeY, size*0.22, size*0.28, 0, 0, Math.PI*2);
    ctx.fill();

    // White highlights in eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(-eyeXoffset - size*0.06, eyeY - size*0.07, size*0.07, size*0.1, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(eyeXoffset - size*0.06, eyeY - size*0.07, size*0.07, size*0.1, 0, 0, Math.PI*2);
    ctx.fill();

    // Nose and nostrils subtle black dots
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(0, size*0.15, size*0.08, size*0.05, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  // Draw colorful glowing food star shaped
  function drawFoodItem(x, y, size, color) {
    const glowRadius = size * 2.1;

    // Glow
    let gradient = ctx.createRadialGradient(x, y, size * 0.25, x, y, glowRadius);
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, 'transparent');

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
    ctx.fill();

    // Star shape points count
    const points = 5;

    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
      let r = (i % 2) ? size * 0.4 : size;
      let angle = (i * Math.PI) / points - Math.PI / 2;
      let sx = x + r * Math.cos(angle);
      let sy = y + r * Math.sin(angle);
      if (i === 0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    ctx.closePath();
    ctx.fill();

    // White highlight spots on star
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    for (let i = 0; i < points; i++) {
      let angle = (i * 2 * Math.PI) / points - Math.PI / 2;
      let sx = x + size * 0.6 * Math.cos(angle);
      let sy = y + size * 0.6 * Math.sin(angle);
      ctx.beginPath();
      ctx.arc(sx, sy, size * 0.15, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Clear the canvas
  function clearCanvas() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
  }

  // Update input direction from mouse/touch respecting world coords
  function updateInputDirection() {
    const head = snake[0];
    // Convert viewport mouse coords to world coords for direction
    // Calculate base offset between viewport and world
    let viewportX = head.x;
    let viewportY = head.y;
    let worldInputX = head.x + (inputX - WIDTH / 2);
    let worldInputY = head.y + (inputY - HEIGHT / 2);

    // Wrap world input if out of world
    if (worldInputX < 0) worldInputX += WORLD_WIDTH;
    else if (worldInputX > WORLD_WIDTH) worldInputX -= WORLD_WIDTH;
    if (worldInputY < 0) worldInputY += WORLD_HEIGHT;
    else if (worldInputY > WORLD_HEIGHT) worldInputY -= WORLD_HEIGHT;

    const angle = angleTo(head.x, head.y, worldInputX, worldInputY);
    targetDirection = angle;
  }

  // Update score display
  function updateScore() {
    const scoreboard = document.getElementById('scoreboard');
    scoreboard.textContent = `Score: ${score}`;
  }

  // Setup pointer input handlers
  function setupInput() {
    function pointerMove(evt) {
      evt.preventDefault();
      let x, y;
      if (evt.touches && evt.touches.length > 0) {
        x = evt.touches[0].clientX;
        y = evt.touches[0].clientY;
      } else {
        x = evt.clientX;
        y = evt.clientY;
      }
      x = Math.min(Math.max(0, x), WIDTH);
      y = Math.min(Math.max(0, y), HEIGHT);
      inputX = x;
      inputY = y;
    }
    canvas.addEventListener('mousemove', pointerMove);
    canvas.addEventListener('touchmove', pointerMove, { passive: false });

    inputX = WIDTH / 2;
    inputY = HEIGHT / 2;
  }

  // Main game loop
  function gameLoop() {
    clearCanvas();

    updateInputDirection();
    updateDirection();
    updateSnake();

    let viewportX = snake[0].x;
    let viewportY = snake[0].y;

    // Check food collisions (only those visible in viewport)
    let eatenIndex = -1;
    for (let i=0; i < food.length; i++) {
      let foodItem = food[i];
      // Calculate dist using wrapped world coords
      let dx = Math.abs(foodItem.x - viewportX);
      let dy = Math.abs(foodItem.y - viewportY);
      dx = dx > WORLD_WIDTH/2 ? WORLD_WIDTH - dx : dx;
      dy = dy > WORLD_HEIGHT/2 ? WORLD_HEIGHT - dy : dy;

      if(Math.sqrt(dx*dx + dy*dy) < FOOD_SIZE + SEGMENT_SIZE*0.6) {
        eatenIndex = i;
        break;
      }
    }

    if(eatenIndex !== -1) {
      food.splice(eatenIndex, 1);
      growSnake(5);
      score++;
      updateScore();

      // Add new food with random color away from snake head
      let tries = 0;
      while(tries < 100) {
        const fx = Math.random() * (WORLD_WIDTH - FOOD_SIZE * 2) + FOOD_SIZE;
        const fy = Math.random() * (WORLD_HEIGHT - FOOD_SIZE * 2) + FOOD_SIZE;
        if(distWrapped(fx, fy, snake[0].x, snake[0].y) > 150) {
          food.push({
            x: fx,
            y: fy,
            color: FOOD_COLORS[Math.floor(Math.random() * FOOD_COLORS.length)]
          });
          break;
        }
        tries++;
      }
    }

    // Draw food relative to viewport center
    food.forEach(f => {
      const { x: sx, y: sy } = worldToScreen(f.x, f.y, viewportX, viewportY);
      // Only draw visible
      if(sx >= -FOOD_SIZE && sx <= WIDTH + FOOD_SIZE && sy >= -FOOD_SIZE && sy <= HEIGHT + FOOD_SIZE) {
        drawFoodItem(sx, sy, FOOD_SIZE, f.color);
      }
    });

    // Draw snake segments relative to viewport
    for(let i = snake.length - 1; i >= 1; i--) {
      const seg = snake[i];
      const {x: sx, y: sy} = worldToScreen(seg.x, seg.y, viewportX, viewportY);
      if(sx < -SEGMENT_SIZE || sx > WIDTH + SEGMENT_SIZE || sy < -SEGMENT_SIZE || sy > HEIGHT + SEGMENT_SIZE) 
        continue;
      drawSegment(sx, sy, seg.angle, SEGMENT_SIZE);
    }
    // Draw head
    const head = snake[0];
    const {x: hx, y: hy} = worldToScreen(head.x, head.y, viewportX, viewportY);
    drawHead(hx, hy, head.angle, SEGMENT_SIZE * 1.35);

    requestAnimationFrame(gameLoop);
  }

  // Distance with wrapping in world coords
  function distWrapped(x1, y1, x2, y2) {
    let dx = Math.abs(x1 - x2);
    let dy = Math.abs(y1 - y2);
    if(dx > WORLD_WIDTH/2) dx = WORLD_WIDTH - dx;
    if(dy > WORLD_HEIGHT/2) dy = WORLD_HEIGHT - dy;
    return Math.sqrt(dx*dx + dy*dy);
  }

  // Initialization
  function init() {
    initSnake();
    initFood();
    setupInput();
    updateScore();
    requestAnimationFrame(gameLoop);
  }
  init();
})();
</script>
</body>
</html>


